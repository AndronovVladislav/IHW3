# Андронов Владислав Артёмович, БПИ213
# Вариант 32
## Условие задачи
Разработать программу, определяющую корень уравнения $2^{x^2 + 1} + x^2 - 4 = 0$ методом половинного деления с точностью = $0.00001$ в диапазоне $[0; 1]$. Если диапазон некорректен, то подобрать корректный диапазон.
## На 6
### Опции компиляции
**1.1 gcc -O0 -fno-asynchronous-unwind-tables -fcf-protection=none pure_c.c -o filename.s -lm**

**1.2 gcc -O0 filename.s -o pure_c.o -lm**

**2.2 gcc main.s funcs.s -lm**

Были добавлены комментарии, поясняющие как использование переменных языка Си конвертируется в использование в регистов процессора. Были вручную раскрыты все макросы _leave_. Программа на Си не потребовала изменений для использования локальных переменных, так как не использовала глобальные переменные и функции в ней изначально были написаны с передачей данных через параметры. Также были внесены необходимы комментарии на 5 баллов.

Также добавлен файл, в котором программа частично переработана. Слегка переработана функция _sign_, полностью переписана функция _f_, а вот функция _bisection_solution_ не была затронута, так как в коде не было замечено мест, в которых можно провести значительные оптимизации.

### Тестовое покрытие на 4
![image](https://user-images.githubusercontent.com/97717897/202545362-a16b5fff-19a0-4746-b772-ff2c96dbde01.png)

### Тестовое покрытие на 6
![image](https://user-images.githubusercontent.com/97717897/202596137-cc01a5c1-5750-497f-8d94-011115752ff7.png)

## На 9
### На 7
Программа на ассемблере осталось разбитой на два модуля main.s и funcs.s. Оба модуля подверглись рефакторингу, в main.s стали использоваться функции fopen, fclose, fscanf и fprintf. Программу запускать с указанием сначала названия файла с вводными данными данными(файл __должен__ существовать), затем названия файла для выходных данных.

### Тестовое покрытие на 7
![image](https://user-images.githubusercontent.com/97717897/202731898-6042a247-af1f-44e1-870e-4581faec4407.png)

Взглянув на содержимое файлов с тестами и сравнив с предыдущими результатами работы программы, легко видеть, что программа на тех же тестах, что и первоначальная программа, работает корректно.

### На 8
В программу была добавлена возможность запуска в режиме случайного теста. Для этого достаточно запустить скомпилированную программу командой ./filename -r file_for_output.txt, при этом результат работы программы записывается в file_for_output.txt, а в терминал выводится настоящее время работы функции _bisection_solution_, легко сопоставимое с 1 секундой. Работа с файлами осуществляется как прежде. Замеры по времени имплементированы, как и требуют критерии, в программу на C и на ассемблере, полученную после рефакторинга, то есть в файлы из папки *For_6*. Результаты замеров представлены ниже.

![image](https://user-images.githubusercontent.com/97717897/202736306-e7e57087-93a9-442f-a25a-0282ba2fc0b0.png)

Из таблицы видно, что обе реализации алгоритма работают очень быстро(порядка O(log(1))), но код на ассемблере имеет большую устойчивость(разбор времени работы меньше).

Также стоит отметить, что при разных запусках программы в режиме случайного теста могут выводиться одинаковые числа, так как стандартный генератор случайных чисел в Си имеет ограниченную случайность.

### На 9
Сравнение ассемблерного файла с файлом на Си, оптимизированном с помощью флагов -O0, -O1, -O2, -O3, -Ofast, -Os:
![image](https://user-images.githubusercontent.com/97717897/202742255-55cffd46-775b-4e73-88b0-b35184443f31.png)

Как видим, флаги -O3/fast/s дают значительный прирост в скорости выполнения программы, и даже делают программу быстрее написанной вручную, однако ни один из флагов не позволяет сделать ассемблерный код короче написанного вручную.

Также видим, что флаги -O1/2/3/s дают одинаковый размер исполняемого файла, меньше, чем размер исполняемого файла, порождаемого ассемблерным кодом, написанным вручную, -Ofast же напротив, заметно повышает размер исполняемого файла, чтобы обеспечить максимальное быстродействие. -O0 же даёт минимальный размер.
